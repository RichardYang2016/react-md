{"version":3,"sources":["../../../src/js/utils/PropTypes/controlled.js"],"names":["controlled","validator","funcName","fallbackPropName","validate","props","propName","componentName","location","propFullName","componentNameSafe","propFullNameSafe","args","err","readOnly","disabled","funcError","func","isRequired","Error"],"mappings":";;;;;kBAYwBA,U;;AAXxB;;;;;;AAEA;;;;;;;;;AASe,SAASA,UAAT,CAAoBC,SAApB,EAA+BC,QAA/B,EAA4E;AAAA,MAAnCC,gBAAmC,uEAAhB,cAAgB;;AACzF,SAAO,SAASC,QAAT,CAAkBC,KAAlB,EAAyBC,QAAzB,EAAmCC,aAAnC,EAAkDC,QAAlD,EAA4DC,YAA5D,EAAmF;AACxF,QAAMC,oBAAoBH,iBAAiB,eAA3C;AACA,QAAMI,mBAAmBF,gBAAgBH,QAAzC;;AAFwF,sCAANM,IAAM;AAANA,UAAM;AAAA;;AAIxF,QAAIC,MAAMZ,4BAAUI,KAAV,EAAiBC,QAAjB,EAA2BC,aAA3B,EAA0CC,QAA1C,EAAoDC,YAApD,SAAqEG,IAArE,EAAV;AACA,QAAI,CAACC,GAAD,IAAQ,OAAOR,MAAMC,QAAN,CAAP,KAA2B,WAAnC,IAAkD,CAACD,MAAMS,QAAzD,IAAqE,CAACT,MAAMU,QAAhF,EAA0F;AAAA;;AACxF,UAAMC,YAAY,uCAAUC,IAAV,EAAeC,UAAf,yBAA0Bb,KAA1B,EAAiCH,QAAjC,EAA2CK,aAA3C,EAA0DC,QAA1D,EAAoEC,YAApE,SAAqFG,IAArF,EAAlB;AACA,UAAII,SAAJ,EAAe;AACbH,cAAM,IAAIM,KAAJ,CACJ,qBAAoBR,gBAApB,UAA0CH,QAA1C,gBAA6DE,iBAA7D,0BACKR,QADL,uEACiFA,QADjF,6BAEgBC,gBAFhB,gBADI,CAAN;AAKD;AACF;;AAED,WAAOU,GAAP;AACD,GAjBD;AAkBD,C,CA/BD","file":"controlled.js","sourcesContent":["/** @module utils/PropTypes/controlled */\r\nimport PropTypes from 'prop-types';\r\n\r\n/**\r\n * Validates the a component is fully controlled or uncontrolled.  If the given prop is not\r\n * `undefined`, it will check if the `funcName` is defined and a function. A missing function\r\n * will generate an error similar to the built-in React controlled validation message.\r\n *\r\n * @param {String} funcName - The function name to use for additional validation.\r\n * @param {function} validator - The PropTypes validator to use for the given prop.\r\n * @return {Error} an error or null.\r\n */\r\nexport default function controlled(validator, funcName, fallbackPropName = 'defaultValue') {\r\n  return function validate(props, propName, componentName, location, propFullName, ...args) {\r\n    const componentNameSafe = componentName || '<<anonymous>>';\r\n    const propFullNameSafe = propFullName || propName;\r\n\r\n    let err = validator(props, propName, componentName, location, propFullName, ...args);\r\n    if (!err && typeof props[propName] !== 'undefined' && !props.readOnly && !props.disabled) {\r\n      const funcError = PropTypes.func.isRequired(props, funcName, componentName, location, propFullName, ...args);\r\n      if (funcError) {\r\n        err = new Error(\r\n          `You provided a \\`${propFullNameSafe}\\` ${location} to the ${componentNameSafe} without a ` +\r\n          `\\`${funcName}\\` handler. This will render a read only field. Set either the \\`${funcName}\\` ` +\r\n          `or use the \\`${fallbackPropName}\\` instead.`\r\n        );\r\n      }\r\n    }\r\n\r\n    return err;\r\n  };\r\n}\r\n"]}