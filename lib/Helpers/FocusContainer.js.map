{"version":3,"sources":["../../src/js/Helpers/FocusContainer.js"],"names":["hrefables","map","tag","join","disableables","FOCUSABLE_QUERY","FocusContainer","_enableFocusTrap","window","addEventListener","_handleKeyDown","_disableFocusTrap","removeEventListener","_attemptInitialFocus","_container","initialFocus","props","toFocus","document","getElementById","querySelector","_focusables","debugError","process","env","NODE_ENV","Error","focus","_containFocus","containerRef","focusOnMount","containFocus","Array","prototype","slice","call","querySelectorAll","filter","el","tabIndex","e","_shifted","shiftKey","additionalFocusKeys","length","preventDefault","target","first","focusables","last","nextProps","Component","component","propTypes","oneOfType","string","func","isRequired","style","object","className","children","node","bool","arrayOf","number","defaultProps"],"mappings":"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","file":"FocusContainer.js","sourcesContent":["import React, { PureComponent } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { findDOMNode } from 'react-dom';\r\n\r\nimport isValidFocusKeypress from '../utils/EventUtils/isValidFocusKeypress';\r\n\r\nconst hrefables = ['a', 'area'].map(tag => `${tag}[href],`).join('');\r\nconst disableables = ['button', 'input', 'textarea', 'select'].map(tag => `${tag}:not([disabled]),`).join('');\r\nconst FOCUSABLE_QUERY = `${hrefables}${disableables}*[tabIndex]`;\r\n\r\n/**\r\n * This component is used for keeping the focus within some container. When the container\r\n * is mounted and the `focusOnMount` prop is `true`, it will attempt to focus either:\r\n * - an element that matches `document.getElementById(this.props.initialFocus)`\r\n * - an element that matches `this._container.querySelector(this.props.initialFocus)`\r\n * - the first focusable element in it's children (if `this.props.initialFocus` is omitted)\r\n */\r\nexport default class FocusContainer extends PureComponent {\r\n  static propTypes = {\r\n    /**\r\n     * The component to render as. This can be a React DOM element or\r\n     * a react Component.\r\n     */\r\n    component: PropTypes.oneOfType([\r\n      PropTypes.string,\r\n      PropTypes.func,\r\n    ]).isRequired,\r\n\r\n    /**\r\n     * An optional style to apply.\r\n     */\r\n    style: PropTypes.object,\r\n\r\n    /**\r\n     * An optional className to apply.\r\n     */\r\n    className: PropTypes.string,\r\n\r\n    /**\r\n     * The children to display.\r\n     */\r\n    children: PropTypes.node,\r\n\r\n    /**\r\n     * An optional id string or a query selector string to use for the initial focus.\r\n     * This will only be triggered if the `focusOnMount` prop is `true`. If this is\r\n     * omitted and the `focusOnMount` prop is `true`, the first focusable element in the\r\n     * container will be focused.\r\n     *\r\n     * Examples:\r\n     *\r\n     * ```js\r\n     * initialFocus=\"#someAmazingId\"\r\n     * // or\r\n     * initialFocus=\".md-btn,.md-list-tile\"\r\n     * ```\r\n     */\r\n    initialFocus: PropTypes.string,\r\n\r\n    /**\r\n     * Boolean if an element in the container should be focused when mounted.\r\n     */\r\n    focusOnMount: PropTypes.bool,\r\n\r\n    /**\r\n     * An optional list of additional key codes to use for focus events.\r\n     */\r\n    additionalFocusKeys: PropTypes.arrayOf(PropTypes.number),\r\n\r\n    /**\r\n     * Boolean if the focus container should start or stop containing the focus within the container.\r\n     * This is useful for changing the focus requirements after mount.\r\n     */\r\n    containFocus: PropTypes.bool,\r\n  };\r\n\r\n  static defaultProps = {\r\n    component: 'div',\r\n    containFocus: true,\r\n  };\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (this.props.containFocus === nextProps.containFocus) {\r\n      return;\r\n    }\r\n\r\n    if (nextProps.containFocus) {\r\n      this._enableFocusTrap();\r\n      this._attemptInitialFocus();\r\n    } else {\r\n      this._disableFocusTrap();\r\n    }\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    if (this.props.containFocus && this._container) {\r\n      this._focusables = Array.prototype.slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY))\r\n        .filter(el => el.tabIndex !== -1);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.props.containFocus) {\r\n      this._disableFocusTrap();\r\n    }\r\n  }\r\n\r\n  _enableFocusTrap = () => {\r\n    window.addEventListener('keydown', this._handleKeyDown, true);\r\n  };\r\n\r\n  _disableFocusTrap = () => {\r\n    window.removeEventListener('keydown', this._handleKeyDown, true);\r\n  };\r\n\r\n  _attemptInitialFocus = () => {\r\n    if (!this._container) {\r\n      return;\r\n    }\r\n\r\n    const { initialFocus } = this.props;\r\n\r\n    const toFocus = initialFocus\r\n      ? document.getElementById(initialFocus) || this._container.querySelector(initialFocus)\r\n      : this._focusables[0];\r\n\r\n    let debugError;\r\n    if (!toFocus && initialFocus) {\r\n      debugError = ' The `initialFocus` did not match a document\\'s `id` or was an invalid ';\r\n      debugError += `\\`querySelector\\` for the container. \\`initialFocus\\`: \\`${initialFocus}\\`. `;\r\n      debugError += 'If this was supposed to be an `id`, make sure to prefix with the `#` symbol.';\r\n    }\r\n\r\n    if (process.env.NODE_ENV !== 'production' && !toFocus) {\r\n      throw new Error(\r\n        'You specified that the `FocusContainer` should focus an element on mount, ' +\r\n        'but a focusable element was not found in the children. This could be because ' +\r\n        'the `initialFocus` prop is an invalid id or query selector, or the children ' +\r\n        `do not contain a valid focusable element.${debugError}`\r\n      );\r\n    }\r\n\r\n    if (toFocus) {\r\n      toFocus.focus();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Manages the event listeners to contain the focus within some container.  When the container\r\n   * ref is not null, the container has mounted and then attempts to focus an element inside\r\n   * if the `focusOnMount` prop is `true`.\r\n   */\r\n  _containFocus = (containerRef) => {\r\n    if (containerRef === null) {\r\n      this._container = null;\r\n      this._disableFocusTrap();\r\n      return;\r\n    }\r\n\r\n    const { focusOnMount, containFocus } = this.props;\r\n    this._container = findDOMNode(containerRef);\r\n    this._focusables = Array.prototype.slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY))\r\n      .filter(el => el.tabIndex !== -1);\r\n\r\n    if (focusOnMount) {\r\n      this._attemptInitialFocus();\r\n    }\r\n\r\n    if (containFocus) {\r\n      this._enableFocusTrap();\r\n    }\r\n  };\r\n\r\n  _handleKeyDown = (e) => {\r\n    this._shifted = e.shiftKey;\r\n    if (!isValidFocusKeypress(e, this.props.additionalFocusKeys)) {\r\n      return;\r\n    } else if (this._focusables.length === 1) {\r\n      e.preventDefault();\r\n      return;\r\n    }\r\n\r\n    const { target, shiftKey } = e;\r\n    const [first, ...focusables] = this._focusables;\r\n    const last = focusables[focusables.length - 1];\r\n\r\n    if (shiftKey && target === first) {\r\n      e.preventDefault();\r\n      last.focus();\r\n    } else if (!shiftKey && target === last) {\r\n      e.preventDefault();\r\n      first.focus();\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      component: Component,\r\n      /* eslint-disable no-unused-vars */\r\n      initialFocus,\r\n      focusOnMount,\r\n      containFocus,\r\n      additionalFocusKeys,\r\n      /* eslint-enable no-unused-vars */\r\n      ...props\r\n    } = this.props;\r\n\r\n    return <Component {...props} ref={this._containFocus} />;\r\n  }\r\n}\r\n"]}